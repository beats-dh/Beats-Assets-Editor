# ğŸ’¾ State & Cache Report - Tibia Assets Editor

> **Analysis of state management and caching strategies**  
> Generated by: AGENT_STATE_CACHE  
> Date: 2024-11-20

---

## ğŸ“‹ Executive Summary

Analysis of global state, caching mechanisms, and potential consistency issues.

### Overall Assessment

âœ… **EXCELLENT**: Well-designed caching with DashMap and Arc  
âœ… **GOOD**: Clear separation between backend and frontend state  
âš ï¸ **MODERATE**: Some cache invalidation could be more explicit  

---

## ğŸ—ï¸ State Architecture

### Backend State (Rust)

```rust
pub struct AppState {
    // Core data (parking_lot locks - 3x faster)
    pub appearances: RwLock<Option<Appearances>>,
    pub sprite_loader: RwLock<Option<SpriteLoader>>,
    pub tibia_path: Mutex<Option<PathBuf>>,

    // Lock-free concurrent caches (DashMap)
    pub sprite_cache: DashMap<String, Arc<Vec<Vec<u8>>>>,
    pub preview_cache: DashMap<String, Arc<Vec<u8>>>,

    // O(1) lookup indexes
    pub object_index: DashMap<u32, usize>,
    pub outfit_index: DashMap<u32, usize>,
    pub effect_index: DashMap<u32, usize>,
    pub missile_index: DashMap<u32, usize>,

    // Search cache
    pub search_cache: DashMap<String, Arc<Vec<u32>>>,

    // Clipboard
    pub flags_clipboard: Mutex<Option<CompleteFlags>>,
}
```

âœ… **Strengths**:
- Lock-free caches with DashMap
- Arc for zero-copy sharing
- parking_lot for faster locks
- Clear ownership model

### Frontend State (TypeScript)

**Distributed across modules**:
- `spriteCache.ts` - Sprite URL caching
- `modalState.ts` - Modal state tracking
- `assetUI.ts` - Grid state (page, filters)
- `localStorage` - Persistent settings

âœ… **Strengths**:
- Modular organization
- Clear responsibilities
- Persistent settings

---

## ğŸš¨ Potential Issues

### 1. Cache Invalidation Gaps

**Issue**: Some caches may not be invalidated when data changes

**Example**:
```rust
// When appearance is updated, these caches should be cleared:
state.sprite_cache.clear(); // âœ… Cleared
state.preview_cache.clear(); // âœ… Cleared
state.search_cache.clear(); // âœ… Cleared
// But what about frontend caches?
```

**Recommendation**: Add explicit cache invalidation events:
```typescript
// Frontend should listen for cache invalidation
document.addEventListener('cache-invalidate', (e) => {
  const { category, id } = e.detail;
  invalidateSpriteCaches(category, id);
});
```

### 2. Race Conditions in Cache Population

**Issue**: Multiple requests for same data could populate cache multiple times

**Current**: DashMap handles concurrent access safely  
**Concern**: Redundant work if multiple requests arrive simultaneously

**Recommendation**: Use entry API to ensure single computation:
```rust
state.sprite_cache.entry(key.clone())
    .or_insert_with(|| {
        // Compute sprite only once
        Arc::new(load_sprite(id))
    })
```

### 3. Unbounded Cache Growth

**Issue**: Caches grow indefinitely without size limits

**Risk**: Memory exhaustion with large datasets

**Recommendation**: Implement LRU eviction:
```rust
// Add cache size tracking
if sprite_cache.len() > MAX_CACHE_SIZE {
    // Evict oldest entries
    evict_lru_entries(&sprite_cache);
}
```

---

## âš ï¸ State Consistency Issues

### 4. Frontend-Backend State Sync

**Issue**: Frontend state may become stale after backend updates

**Example**:
```typescript
// Frontend has cached appearance list
const cachedList = assetsQueryCache.get(key);

// Backend updates appearance
await invoke('update_appearance_name', { ... });

// Frontend cache is now stale!
```

**Recommendation**: Clear frontend caches after mutations:
```typescript
export function clearAssetsQueryCaches(): void {
  assetsQueryCache.clear();
  enqueuedAnimations.clear();
  animationQueue.length = 0;
}

// Call after every mutation
await invoke('update_appearance_name', { ... });
clearAssetsQueryCaches();
await loadAssets(); // Refresh
```

### 5. localStorage Persistence

**Issue**: localStorage data may become invalid after app updates

**Risk**: Stale paths, invalid settings

**Recommendation**: Add version checking:
```typescript
const STORAGE_VERSION = '1.0';
const storedVersion = localStorage.getItem('storageVersion');

if (storedVersion !== STORAGE_VERSION) {
  // Clear stale data
  localStorage.clear();
  localStorage.setItem('storageVersion', STORAGE_VERSION);
}
```

---

## ğŸ“Š Cache Performance Analysis

### Backend Caches

| Cache | Type | Size Limit | Eviction | Status |
|-------|------|------------|----------|--------|
| sprite_cache | DashMap | âŒ None | âŒ None | âš ï¸ Unbounded |
| preview_cache | DashMap | âŒ None | âŒ None | âš ï¸ Unbounded |
| search_cache | DashMap | âŒ None | âœ… Manual clear | âš ï¸ Unbounded |
| object_index | DashMap | âœ… Fixed | N/A | âœ… Good |
| outfit_index | DashMap | âœ… Fixed | N/A | âœ… Good |

### Frontend Caches

| Cache | Type | Size Limit | Eviction | Status |
|-------|------|------------|----------|--------|
| spriteCache | Map | âŒ None | âŒ None | âš ï¸ Unbounded |
| previewSpriteCache | Map | âŒ None | âŒ None | âš ï¸ Unbounded |
| assetsQueryCache | Map | âŒ None | âœ… Manual clear | âš ï¸ Unbounded |
| detailSpriteCache | Map | âŒ None | âŒ None | âš ï¸ Unbounded |

---

## ğŸ¯ Recommendations

### High Priority

1. **Add Cache Size Limits**
   ```rust
   const MAX_SPRITE_CACHE_SIZE: usize = 1000;
   const MAX_PREVIEW_CACHE_SIZE: usize = 500;
   ```

2. **Implement LRU Eviction**
   - Track access times
   - Evict least recently used entries
   - Consider using `lru` crate

3. **Add Cache Invalidation Events**
   - Emit events when data changes
   - Frontend listens and clears caches
   - Ensures consistency

### Medium Priority

4. **Add Cache Statistics**
   ```rust
   #[tauri::command]
   pub async fn get_cache_stats(state: State<'_, AppState>) -> CacheStats {
       CacheStats {
           sprite_cache_size: state.sprite_cache.len(),
           preview_cache_size: state.preview_cache.len(),
           search_cache_size: state.search_cache.len(),
           // ... memory usage, hit rates, etc.
       }
   }
   ```

5. **Add localStorage Versioning**
   - Version all stored data
   - Clear on version mismatch
   - Migrate old data if possible

6. **Document Cache Lifetimes**
   - When caches are populated
   - When caches are invalidated
   - Expected memory usage

### Low Priority

7. **Add Cache Warming**
   - Pre-populate common sprites
   - Load frequently accessed data
   - Improve perceived performance

8. **Add Cache Metrics**
   - Track hit/miss rates
   - Monitor memory usage
   - Identify optimization opportunities

---

## ğŸ† Strengths

1. **Lock-Free Design**: DashMap enables safe concurrent access
2. **Zero-Copy Sharing**: Arc prevents unnecessary clones
3. **Fast Locks**: parking_lot is 3x faster than std
4. **Clear Separation**: Backend and frontend caches are distinct
5. **Manual Control**: Explicit cache clearing when needed

---

## ğŸ“ˆ Cache Usage Patterns

### Sprite Loading Pattern

```
1. Frontend requests sprite
2. Backend checks sprite_cache
   â”œâ”€ HIT: Return cached Arc<Vec<u8>>
   â””â”€ MISS:
      â”œâ”€ Load from catalog
      â”œâ”€ Decompress LZMA
      â”œâ”€ Encode as PNG
      â”œâ”€ Store in cache (Arc)
      â””â”€ Return
3. Frontend caches data URL
4. Display in UI
```

âœ… **Efficient**: Avoids redundant decompression and encoding

### Search Caching Pattern

```
1. User searches for "sword"
2. Backend checks search_cache["Objects:sword:All"]
   â”œâ”€ HIT: Return cached IDs
   â””â”€ MISS:
      â”œâ”€ Filter appearances
      â”œâ”€ Store in cache
      â””â”€ Return
3. Frontend caches results
4. Display in grid
```

âœ… **Efficient**: Avoids redundant filtering

---

**Generated by**: AGENT_STATE_CACHE  
**Date**: 2024-11-20  
**Version**: 1.0.0
