# üîç Code Smells Report - Tibia Assets Editor

> **Analysis of code quality issues and maintainability concerns**  
> Generated by: AGENT_CODE_SMELL  
> Date: 2024-11-20

---

## üìã Executive Summary

Analysis of code smells, bad practices, and maintainability issues in both Rust and TypeScript code.

### Overall Assessment

‚úÖ **GOOD**: Code is generally well-structured and organized  
‚ö†Ô∏è **MODERATE**: Some functions are too large and complex  
‚ö†Ô∏è **MODERATE**: Some code duplication exists  

---

## ü¶Ä Rust Code Smells

### 1. Large Functions

**Severity**: MODERATE

**Location**: `src-tauri/src/features/appearances/commands/update.rs`

**Issue**: Update functions are very long (100+ lines)

**Example Pattern**:
```rust
pub async fn update_appearance_market(...) -> Result<...> {
    // 150+ lines of logic
    // Multiple nested if statements
    // Complex validation
    // State mutation
    // Cache invalidation
}
```

**Recommendation**: Extract helper functions
```rust
pub async fn update_appearance_market(...) -> Result<...> {
    validate_market_data(&update)?;
    let appearance = find_appearance_mut(&mut appearances, category, id)?;
    apply_market_update(appearance, update)?;
    invalidate_caches(&state, category, id);
    Ok(create_appearance_item(appearance))
}
```

**Impact**: Easier to test, understand, and maintain

### 2. Repeated Error Handling Pattern

**Severity**: LOW

**Location**: Multiple command files

**Issue**: Same error handling pattern repeated

**Example**:
```rust
let appearances_lock = state.appearances.read();
let appearances = appearances_lock
    .as_ref()
    .ok_or_else(|| "Appearances not loaded".to_string())?;
```

**Recommendation**: Create helper function
```rust
fn get_appearances(state: &AppState) -> Result<&Appearances, String> {
    state.appearances.read()
        .as_ref()
        .ok_or_else(|| "Appearances not loaded".to_string())
}
```

**Impact**: DRY principle, less repetition

### 3. Magic Numbers

**Severity**: LOW

**Location**: Various files

**Issue**: Hardcoded numbers without explanation

**Example**:
```rust
if brightness > 255 {
    return Err("Invalid brightness".to_string());
}
```

**Recommendation**: Use constants
```rust
const MAX_BRIGHTNESS: u32 = 255;

if brightness > MAX_BRIGHTNESS {
    return Err(format!("Brightness must be <= {}", MAX_BRIGHTNESS));
}
```

**Impact**: Self-documenting code

### 4. String Error Messages

**Severity**: LOW

**Location**: All command files

**Issue**: Error messages are plain strings

**Example**:
```rust
return Err("Failed to load appearances".to_string());
```

**Recommendation**: Use structured errors
```rust
#[derive(Debug, thiserror::Error)]
pub enum AppearanceError {
    #[error("Appearances not loaded")]
    NotLoaded,
    #[error("Invalid ID: {0}")]
    InvalidId(u32),
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}
```

**Impact**: Better error handling, type safety

---

## üåê TypeScript Code Smells

### 1. God Objects

**Severity**: HIGH

**Location**: `src/assetUI.ts`, `src/assetDetails.ts`

**Issue**: Files are too large (1000+ lines) with many responsibilities

**Example**: `assetUI.ts` handles:
- Asset loading
- Grid rendering
- Pagination
- Search
- Caching
- Animation queueing
- Event handling

**Recommendation**: Split into smaller modules
```
src/assetUI/
  ‚îú‚îÄ‚îÄ assetLoader.ts      // Loading logic
  ‚îú‚îÄ‚îÄ assetRenderer.ts    // Rendering logic
  ‚îú‚îÄ‚îÄ assetPagination.ts  // Pagination logic
  ‚îú‚îÄ‚îÄ assetSearch.ts      // Search logic
  ‚îî‚îÄ‚îÄ assetCache.ts       // Caching logic
```

**Impact**: Better organization, easier to maintain

### 2. Callback Hell

**Severity**: MODERATE

**Location**: `src/assetDetails.ts`

**Issue**: Nested callbacks and promises

**Example**:
```typescript
scheduleIdle(() => {
  void renderBatch(0).then(() => {
    scheduleIdle(() => {
      void initAnimations().then(() => {
        // ...
      });
    });
  });
});
```

**Recommendation**: Use async/await
```typescript
async function loadAndRender() {
  await renderBatch(0);
  await initAnimations();
}

scheduleIdle(() => void loadAndRender());
```

**Impact**: More readable, easier to debug

### 3. Excessive Use of 'any'

**Severity**: MODERATE

**Location**: Multiple files

**Issue**: Type safety is lost with 'any'

**Example**:
```typescript
const response = await invoke('list_appearances', { ... }) as any;
const items: any[] = response.items;
```

**Recommendation**: Use proper types
```typescript
interface ListResponse {
  total: number;
  items: AppearanceItem[];
}

const response = await invoke<ListResponse>('list_appearances', { ... });
const items: AppearanceItem[] = response.items;
```

**Impact**: Type safety, better IDE support

### 4. Long Parameter Lists

**Severity**: LOW

**Location**: Various functions

**Issue**: Functions with many parameters

**Example**:
```typescript
function createAssetElement(
  id: number,
  name: string,
  category: string,
  hasFlags: boolean,
  isSelected: boolean,
  showName: boolean
) { ... }
```

**Recommendation**: Use options object
```typescript
interface AssetElementOptions {
  id: number;
  name: string;
  category: string;
  hasFlags: boolean;
  isSelected: boolean;
  showName: boolean;
}

function createAssetElement(options: AssetElementOptions) { ... }
```

**Impact**: More flexible, easier to extend

### 5. Global State Mutation

**Severity**: MODERATE

**Location**: Multiple files

**Issue**: Module-level variables mutated from many places

**Example**:
```typescript
let currentCategory = 'Objects';
let currentPage = 0;
let currentSearch = '';

// Mutated from many functions
export function switchCategory(category: string) {
  currentCategory = category;
  currentPage = 0;
  // ...
}
```

**Recommendation**: Encapsulate in class or object
```typescript
class AssetGridState {
  private category = 'Objects';
  private page = 0;
  private search = '';

  switchCategory(category: string) {
    this.category = category;
    this.page = 0;
    // ...
  }

  // Getters and setters
}

export const gridState = new AssetGridState();
```

**Impact**: Better encapsulation, easier to test

### 6. Inconsistent Naming

**Severity**: LOW

**Location**: Various files

**Issue**: Inconsistent naming conventions

**Examples**:
- `loadAssets()` vs `load_appearances_file()`
- `assetDetails` vs `asset-details`
- `spriteCache` vs `sprite_cache`

**Recommendation**: Establish conventions
- Functions: camelCase
- Files: kebab-case
- CSS classes: kebab-case
- Constants: UPPER_SNAKE_CASE

**Impact**: Consistency, professionalism

### 7. Magic Strings

**Severity**: LOW

**Location**: Multiple files

**Issue**: Hardcoded strings repeated

**Example**:
```typescript
document.querySelector('#assets-grid');
document.querySelector('#assets-grid');
document.querySelector('#assets-grid');
```

**Recommendation**: Use constants
```typescript
const SELECTORS = {
  ASSETS_GRID: '#assets-grid',
  ASSET_SEARCH: '#asset-search',
  // ...
} as const;

document.querySelector(SELECTORS.ASSETS_GRID);
```

**Impact**: DRY principle, easier refactoring

---

## üìä Code Complexity Metrics

### Rust Files

| File | Lines | Functions | Complexity | Status |
|------|-------|-----------|------------|--------|
| update.rs | ~1500 | ~30 | HIGH | ‚ö†Ô∏è Refactor |
| query.rs | ~500 | ~10 | MODERATE | ‚úÖ OK |
| io.rs | ~200 | ~5 | LOW | ‚úÖ Good |

### TypeScript Files

| File | Lines | Functions | Complexity | Status |
|------|-------|-----------|------------|--------|
| assetUI.ts | ~1200 | ~40 | HIGH | ‚ö†Ô∏è Split |
| assetDetails.ts | ~3000 | ~50 | VERY HIGH | üö® Refactor |
| main.ts | ~300 | ~10 | MODERATE | ‚úÖ OK |

---

## üéØ Recommendations

### High Priority

1. **Split Large Files**
   - `assetDetails.ts` (3000 lines) ‚Üí Multiple modules
   - `assetUI.ts` (1200 lines) ‚Üí Feature modules
   - `update.rs` (1500 lines) ‚Üí Smaller functions

2. **Reduce 'any' Usage**
   - Add proper type definitions
   - Use type parameters on invoke()
   - Create interfaces for all data structures

3. **Encapsulate Global State**
   - Use classes or objects
   - Avoid module-level mutations
   - Better testability

### Medium Priority

4. **Extract Helper Functions**
   - Break down large functions
   - Create reusable utilities
   - Improve readability

5. **Use Structured Errors (Rust)**
   - Replace String errors with enums
   - Better error handling
   - Type-safe error propagation

6. **Add Constants**
   - Replace magic numbers
   - Replace magic strings
   - Self-documenting code

### Low Priority

7. **Improve Naming Consistency**
   - Establish conventions
   - Rename inconsistent identifiers
   - Update documentation

8. **Add JSDoc Comments**
   - Document complex functions
   - Explain non-obvious logic
   - Improve IDE support

9. **Reduce Code Duplication**
   - Extract common patterns
   - Create shared utilities
   - DRY principle

---

## üèÜ Code Quality Strengths

### Rust
1. **Strong Type System**: Excellent use of Rust's type system
2. **Error Handling**: Consistent use of Result types
3. **Memory Safety**: No unsafe code blocks
4. **Concurrency**: Safe concurrent access with DashMap
5. **Performance**: Well-optimized with parking_lot and Arc

### TypeScript
1. **Strict Mode**: TypeScript strict mode enabled
2. **Modular CSS**: Separate CSS files for features
3. **Web Workers**: Good use of background processing
4. **Async/Await**: Modern async patterns
5. **Feature Organization**: Features grouped logically

---

## üìà Refactoring Roadmap

### Phase 1: Critical (1 week)
- Split `assetDetails.ts` into modules
- Split `assetUI.ts` into modules
- Reduce 'any' usage in critical paths

### Phase 2: Important (2 weeks)
- Extract large Rust functions
- Encapsulate global state
- Add structured errors in Rust

### Phase 3: Nice to Have (1 month)
- Add constants for magic values
- Improve naming consistency
- Add comprehensive JSDoc comments
- Reduce code duplication

---

## üìö Best Practices to Adopt

### General
1. **Single Responsibility**: One function, one purpose
2. **DRY Principle**: Don't repeat yourself
3. **KISS Principle**: Keep it simple, stupid
4. **YAGNI**: You aren't gonna need it

### Rust
1. Use `thiserror` for structured errors
2. Extract helper functions for common patterns
3. Use constants for magic numbers
4. Document public APIs with rustdoc

### TypeScript
1. Avoid 'any' - use proper types
2. Use options objects for many parameters
3. Encapsulate state in classes/objects
4. Use constants for magic strings
5. Add JSDoc for complex functions

---

**Generated by**: AGENT_CODE_SMELL  
**Date**: 2024-11-20  
**Version**: 1.0.0
